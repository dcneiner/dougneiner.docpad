<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Doug Neiner</title>
    <link href="http://code.dougneiner.com/atom.xml" rel="self"/>
    <link href="http://code.dougneiner.com"/>
    <updated>2012-02-27T04:32:02Z</updated>
    <id>http://code.dougneiner.com</id>
    <author>
        <name>Doug Neiner</name>
        <email>doug@dougneiner.com</email>
    </author>

    
        
    
        
            <entry>
                <title>Using CSS Classes with jQuery to Control Visual State</title>
                
                <link href="http://code.dougneiner.com/coding/using-css-classes-for-states-alt.html"/>
                
                <updated>2012-02-27T04:26:14Z</updated>
                <id>http://code.dougneiner.com/coding/using-css-classes-for-states-alt.html</id>
                <content type="html">## Strategy

Instead of showing, hiding, and otherwise adjusting an HTML element's visual display with jQuery, execute the same level of change by strategically adding and removing classes with jQuery/JavaScript. The classes can be applied on the component, region, and page level to control any static state of the host element or its decedents.

## Symptoms

You can easily detect when to use this strategy when you discover yourself performing any of the following actions:

* You show, hide, or otherwise visually adjust two or more elements at the same time. The higher the number of elements changed, the greater the need for this strategy.

* You need to run any number of jQuery selections via `$( selector )`, `.find()`, etc, just to adjust the visual display of those elements.

* You use jQuery’s [`.css()`](http://api.jquery.com/css) method to change an element from one visual appearance to another predetermined appearance.


### Problem 1

The following code illustrates the first two of these symptoms:

```javascript
$( document ).ready( function () {
    // Three separate elements are selected
    var loadingMessage = $( "#loadingMessage" ),
        header = $( "#header" ),
        content = $( "#content" );

    // Three CSS changes are made:
    loadingMessage.show();
    header.hide();
    content.hide();

    // Lots of setup and async code here

    function someReadyCallback () {
        // Three additional CSS changes are made
        loadingMessage.hide();
        header.show();
        content.show();
    }
});
```

### Problem 2

This short example illustrates the third symptom:

```javascript
var $notification = $( ".notification" );
if ( error ) {
    $notification.css( "color", "red" );
} else {
    $notification.css( "color", "green" );
}
```

## Solutions

### Solution 1

To visually adjust **multiple items** at the same time, follow these steps:

1. Find a parent element that is shared by the elements you wish to adjust. Often you can use the `html` or `body` element, but it can be any element that contains all the target elements.
2. Determine a good CSS class name to describe the *combined* visual state of the elements, optionally add that class to the HTML and then manipulate it by using jQuery’s [`addClass`](http://api.jquery.com/addClass), [`removeClass`](http://api.jquery.com/removeClass) and [`toggleClass`](http://api.jquery.com/toggleClass) methods. Prefixing these classes with `state-` is one way to signify their purpose.
3. Write CSS that scopes selections using a combination of the chosen parent element and the new class that is being applied to it.

The CSS to fix our `loadingMessage` code would look like this:

```css
/* Loading message is hidden by default, only shown during loading */
#loadingMessage { display: none; }
.state-loading #loadingMessage { display: block; }

/* Content and Header are hidden during loading */
.state-loading #content,
.state-loading #header { display: none; }
```

Since the page will always start in a loading state, we add the class of `loading` directly to the `<body>` element:

```html
<body class="state-loading">
```

Finally, we delete almost all the code we had before, and just remove the `loading` class when loading is complete:

```javascript
// Lots of setup and async code here

function someReadyCallback () {
    // The app is loaded!
    $( document.body ).removeClass( "state-loading" );
} 
```

### Solution 2

To adjust the visual display of a **single item**, follow these steps:

1. Any aspect of the visual display that will not change should be defined as the element’s default display.
2. Determine a good class name to describe the new visual state of the element, optionally add that class to the HTML for the element and then manipulate it by using jQuery’s class manipulation methods.
3. Write CSS that scopes the new styles to the chosen element with the new class applied. You can also use multiple class syntax if you the element you are styling is already defined by a class: `.notification.ready` (Multiple class syntax is not supported by IE6 and lower).

If we assume the default state of our notification display is `green`, we can use the following CSS:

```css
.notification { color: green; }
.notification.state-error { color: red; }
```

The following code will add the class of `state-error` when our variable `error` is true:

```javascript
var $notification = $( ".notification" );
$notification.toggleClass( "state-error", error );
```


## Strengths 

* **Speed** – By strategically using classes instead of direct manipulation, you remove the need to find, then adjust multiple elements. Very little code is needed to add or remove a class, replaced potentially slow moving code (selectors and traversal) with extremely efficient code. By leaving the bulk of the changes up to the browser, you also capitalize on the speed of the browser’s CSS engine.
* **Separation of functionality and style** – By only manipulating a class name, you leave the bulk of the visual definition in the CSS files – where they belong. In a team setting, this also allows a designer to modify the design without interacting with the JavaScript.
* **Self describing code** – If the class names you choose are descriptive, then where they are added and removed is afforded an immediate increased in clarity.
* **Scoped events with delegation** – You can leverage these class names to automatically filter out unwanted event triggers based on state. Look at the following example for ideas:

```javascript
$( document )

    // perform the save, but not if we are still
    // loading or in the middle of a save
    .on( "click", "body:not(.loading, .saving) button.save", function () {        
        ...
    })
    
    // prevent forms from submitting
    // if a save is in progress
    .on( "submit", "body.saving", function ( e ) {
        e.preventDefault();
    })
    
    // only run the setup one time per element
    .on( "click", ".widget:not(.widget-setup)", function () {
        ...
        $( this ).addClass( "widget-setup" );
    });
```

## Scribbles

### Transitions

Often the move from one state to another is accompanied by some sort of animation. Since much of the time these transitions are visual finesse, I suggest using CSS3 transitions and animations to implement the transitions. The fallback in unsupported browsers will simply be an instant change from one state to the next. In situations where the animation is crucial to the interaction, you may not be able to leverage everything covered in this article.

### Using Attributes instead of Classes

You can also use attribute changes to control flow, though I haven't done any speed comparisons between the two methods. Here is an example using a custom HTML5 data attribute named `data-state`:

```html
<body data-state="loading">
```

```css
body[data-state="loading"] #loadingMessage,
body[data-state="saving"] #savingMessage { display: block; }
```

```javascript
$body.attr( "state", "ready" ); // From loading to ready
// ... other code ...
$body.attr( "state", "saving" ); // Switch to saving
```
                
                </content>
            </entry>
        
    
        
            <entry>
                <title>Using CSS Classes with jQuery to Control Visual State</title>
                
                <link href="http://code.dougneiner.com/coding/using-css-classes-for-states.html"/>
                
                <updated>2012-02-27T04:14:39Z</updated>
                <id>http://code.dougneiner.com/coding/using-css-classes-for-states.html</id>
                <content type="html">We tend to look at web applications and web sites as a progression of user input and system response. We view their interaction more as a river of information flowing from process to process. Never quite sure what the user will do next, our system attempts to provide the appropriate responses to their input.

If we take a closer look, instead of a constant dynamic stream of responses, we will see various static states on both the component and the page level. Except in games and edge cases, no part of our interface is in a constant state of flux. For example, a complex web application may start in a `loading` state, and then move to a `ready` state after the application is ready for user interaction. Later in the interaction cycle, it might transition to a `saving` state in which most buttons are disabled until the system returns to a `ready` state. 

The temptation is for developers to keep all of the changes associated with these states in the JavaScript code itself. In the case of our `loading` and `ready` states, their code might looks something like this:

```javascript
var loadingMessage = $( "#loadingMessage" ),
    header         = $( "#header" ),
    content        = $( "#content" );

loadingMessage.show();
header.hide();
content.hide();

// Lots of setup and async code here

function someReadyCallback () {
    // The app is loaded!
    loadingMessage.hide();
    header.show();
    content.show();
}
```

The important thing to notice about this example, is that each component is being interacted with directly through jQuery methods. This requires a reference to the elements via direct selection or traversal. It also puts the heavy lifting on jQuery to properly show and hide these elements appropriately.

As we add different states to the application ( `saving`, `data entry`, `fullscreen text entry` ), the need for code like this multiplies.

## Thinking Differently

In order to cut down on this type of jQuery code, we need to widen the focus of our thinking. As soon as we start changing the visual state of multiple items at the same time, we should start to think of a different way of adjusting visual state.

### The Document Object Model

The Document Object Model is often represented as an inverse tree. We start at the root `<html>` element and quickly branch to `<head>` and `<body>`. As we step into the rest of our page structure, we see many branches forming our inverted tree. 

When you cut a branch off a real tree, you are also removing any other branches, twigs and leaves attached to it. In short, modifying a parent branch affects the child limbs. The DOM works the same way, and we can use that to our advantage when we seek to make sweeping changes with minimal effort.

### jQuery's `show` and `hide`

Behind the scenes, jQuery's `show` and `hide` methods are (after a bit of legwork to ensure the proper changes) adjusting `.style.display` on each element. Since that change is made on the element level, it has the same effect as applying `style="display: none"` or `style="display: block"` inline in the HTML. It increases the specificity of the styling, overriding any other `display` setting in the CSS except those with an `!important` designation.


## A New Approach

Now that we realize that we are actually adjusting a single CSS property with JavaScript, lets try optimizing this adjustment. The first thing we want to do, is write CSS to fully describe the two states we are looking for. Since a `ready` state is how our application should look most of the time, we will use that as the default state.

When thinking about states, we should seek to change some aspect of shared parent to affect the children. This can be simply adding a class name, or changing some other attribute of the element that we can respond to in CSS. Lets use a `loading` class applied to the `<body>` element to signify when our application is in a loading state.

Since elements default to being visible, we don't need to do anything special to `#content` and `#header` for our ready state. We do want the `#loadingMessage` to be hidden while in a `ready` state, so we set its default state to `display: none;`. During loading, the `#loadingMessage` should be visible, and both `#content` and `#header` should be hidden. Here is the finished CSS:

```css
#loadingMessage { display: none; }
.loading #loadingMessage { display: block; }

.loading #content,
.loading #header { display: none; }
```

Since the page will always start in a loading state, lets add the class of `loading` directly to the `<body>` element:

```html
<body class="loading">
```

Given the added CSS and class name applied in HTML, our complete solution needed to replace the previous code is as follows:

```javascript
var $body = $( document.body ); // Store a reference

// Lots of setup and async code here

function someReadyCallback () {
    // The app is loaded!
    $body.removeClass( "loading" );
} 
```

We have replaced the selection of three elements with a single reference to `document.body`. And we replaced six separate interactions with the DOM with a single removal of a `loading` class from the `<body>` element.

## Reacting To Specific States

You can combine these state classes with delegated events to write state specific code. Take the following code examples:

```javascript
$( document )
    .on( 
        "click", "body:not(.loading, .saving) button.save", function () {
        // perform the save, but not if we are still
        // loading or in the middle of a save
    })
    .on( "submit", "body.saving", function ( e ) {
        // prevent forms from submitting
        // if a save is in progress
        e.preventDefault();
    });
```

## Using Attributes instead of Classes

With Internet Explorer 7+, you can also use attribute changes to control flow. For certain changes that are atomic, you could use a HTML5 data attribute.

```html
<body data-state="loading">
```

Use a different selector in the CSS:

```css
body[data-state="loading"] #loadingMessage,
body[data-state="saving"] #savingMessage { display: block; }
```

And then change that state with jQuery:

```javascript
$body.attr( "state", "ready" ); // From loading to ready
// ... other code ...
$body.attr( "state", "saving" ); // Switch to saving
```
                
                </content>
            </entry>
        
    
        
    
        
    
        
    
        
    
        
            <entry>
                <title>Essential JavaScript Design Patterns for Beginners</title>
                
                <link href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/"/>
                
                <updated>2012-02-18T20:42:09Z</updated>
                <id>http://code.dougneiner.com/learning/essential-javascript-design-patterns.html</id>
                <content type="html"><p>I really enjoyed Addy's presentation at the jQuery UK Conference where he touched on just a few patterns mentioned in this free online book. I haven't read through it yet, but I am super excited to learn more about some of these patterns. I think I will also find out the names for a number of the patterns I already use!</p>
                
                    <p><a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">View Link &rarr;</a></p>
                
                </content>
            </entry>
        
    
        
    
        
    
        
    
        
            <entry>
                <title>Stop (Mis)Using Return False</title>
                
                <link href="http://code.dougneiner.com/coding/stop-using-return-false.html"/>
                
                <updated>2010-09-20T05:00:00Z</updated>
                <id>http://code.dougneiner.com/coding/stop-using-return-false.html</id>
                <content type="html"><p>Probably one of the first topics covered when you get started learning about jQuery events is the concept of canceling the browser’s default behavior. For instance, a beginner click tutorial may include this:</p>

<div class='code-block code-lang-javascript'><div class="highlight"><pre><span class="nx">$</span><span class="p">(</span><span class="s2">&quot;a.toggle&quot;</span><span class="p">).</span><span class="nx">click</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;#mydiv&quot;</span><span class="p">).</span><span class="nx">toggle</span><span class="p">();</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Prevent browser from visiting `#`</span>
<span class="p">});</span>
</pre></div>
</div>

<p>This function toggles the hiding and displaying of <code>#mydiv</code>, then cancels the browser’s default behavior of visiting the href of the anchor tag.</p>

<p>It is in these very first examples that bad habits are formed as users continue to use <code>return false;</code> whenever they want to cancel the default browser action. I am going to cover two very important topics in this article relating to the canceling of browser events.</p>

<p><a href="http://fuelyourcoding.com/jquery-events-stop-misusing-return-false/">Continue reading at Fuel Your Coding…</a></p>

<p><em>This article was written for and published at Fuel Your Coding, on September 20, 2010. The material covered still applies to jQuery code written today.</em></p>
                
                </content>
            </entry>
        
    
        
            <entry>
                <title>Introduction to Stateful Plugins and the Widget Factory</title>
                
                <link href="http://code.dougneiner.com/coding/introduction-to-stateful-widgets.html"/>
                
                <updated>2010-05-21T05:00:00Z</updated>
                <id>http://code.dougneiner.com/coding/introduction-to-stateful-widgets.html</id>
                <content type="html"><p>The jQuery UI Widget Factory is a separate component of the <a href="http://jqueryui.com">jQuery UI</a> Library that provides an easy, object oriented way to create stateful jQuery plugins. Plugins created using the Widget Factory can be simple or very robust as evidenced by the official jQuery UI widgets, each of which are built on top of the Widget Factory. This article will first look briefly at why you might want to use the Widget Factory, then present an in depth walkthrough of creating a stateful plugin using the Factory.</p>

<p><a href="http://msdn.microsoft.com/en-us/scriptjunkie/ff706600.aspx">Continue reading at Script Junkie…</a></p>

<p><em>This article was written for and published at Script Junkie, on May 21, 2010. This article is current for jQuery UI 1.8, though 1.9 will bring a number of changes when released.</em></p>
                
                </content>
            </entry>
        
    
</feed>